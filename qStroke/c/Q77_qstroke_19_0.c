/* 
 * Copyright 2012 ClinRisk Ltd.
 * 
 * This file is part of QStroke (http://qstroke.org, http://svn.clinrisk.co.uk/opensource/qstroke).
 * 
 * QStroke is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * QStroke is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with QStroke.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Additional terms
 * 
 * The following disclaimer must be displayed alongside any risk score generated by this code.
 *   The initial version of this file, to be found at http://svn.clinrisk.co.uk/opensource/qstroke, faithfully implements QStroke.
 *   We have released this code under the GNU Lesser General Public License to enable others to implement the algorithm faithfully.
 *   However, the nature of the GNU Lesser General Public License is such that we cannot prevent, for example, someone altering the coefficients.
 *   We stress, therefore, that it is the responsibility of the end user to check that the source that they receive produces the same results as the original code posted at http://svn.clinrisk.co.uk/opensource/qstroke.
 *   Inaccurate implementations of risk scores can lead to wrong patients being given the wrong treatment.
 * 
 * This file has been auto-generated.
 * XML source: Q77_qstroke_19_0.xml
 * STATA dta time stamp: 9 Mar 2013 15:23
 * This file was created on: Sat  9 Mar 2013 16:20:26 GMT
 */

#include <math.h>
#include <string.h>
#include <clinrisk/Q77_qstroke_19_0.h>
#include <clinrisk/utils.h>

static double stroke_female_raw(
int age,int b_AF,int b_CCF,int b_chd,int b_ra,int b_renal,int b_treatedhyp,int b_type1,int b_type2,int b_valvular,double bmi,int ethrisk,int fh_cvd,double rati,double sbp,int smoke_cat,int surv,double town
)
{
	double survivor[16] = {
		0,
		0.999592542648315,
		0.999157011508942,
		0.998699188232422,
		0.998193085193634,
		0.997646689414978,
		0.997065961360931,
		0.996467173099518,
		0.995843231678009,
		0.995173335075378,
		0.994471669197083,
		0.993704795837402,
		0.992924809455872,
		0.992103338241577,
		0.991260945796967,
		0.990782141685486
	};

	/* The conditional arrays */

	double Iethrisk[10] = {
		0,
		0,
		-0.0305394929576588490000000,
		0.4427611182840293100000000,
		0.2673795862919842200000000,
		-0.2598308364468712700000000,
		-0.0488012419137342430000000,
		-0.2788553112730757200000000,
		-0.6767143572327304300000000,
		-0.1611535009190185600000000
	};
	double Ismoke[5] = {
		0,
		0.1498305575251711900000000,
		0.4519183493573110700000000,
		0.6146335482699555300000000,
		0.8131785122592680700000000
	};

	/* Applying the fractional polynomial transforms */
	/* (which includes scaling)                      */

	double dage = age;
	dage=dage/10;
	double age_1 = pow(dage,2);
	double age_2 = pow(dage,3);
	double dbmi = bmi;
	dbmi=dbmi/10;
	double bmi_1 = pow(dbmi,-2);
	double bmi_2 = pow(dbmi,-2)*log(dbmi);

	/* Centring the continuous variables */

	age_1 = age_1 - 20.710655212402344;
	age_2 = age_2 - 94.252044677734375;
	bmi_1 = bmi_1 - 0.152111470699310;
	bmi_2 = bmi_2 - 0.143223732709885;
	rati = rati - 3.597237586975098;
	sbp = sbp - 127.181053161621090;
	town = town - -0.092155806720257;

	/* Start of Sum */
	double a=0;

	/* The conditional sums */

	a += Iethrisk[ethrisk];
	a += Ismoke[smoke_cat];

	/* Sum from continuous values */

	a += age_1 * 0.1697320518297478200000000;
	a += age_2 * -0.0093489805139222847000000;
	a += bmi_1 * 2.3158227325733081000000000;
	a += bmi_2 * -8.3927388985024596000000000;
	a += rati * 0.0763818306795134570000000;
	a += sbp * 0.0110106548819008700000000;
	a += town * 0.0569282538300162900000000;

	/* Sum from boolean values */

	a += b_AF * 1.1236185329326394000000000;
	a += b_CCF * 1.0018266666317022000000000;
	a += b_chd * 1.1384605450143492000000000;
	a += b_ra * 0.2895019448611921300000000;
	a += b_renal * 0.3840433250496960200000000;
	a += b_treatedhyp * 0.6000589936358939900000000;
	a += b_type1 * 1.2931653635533871000000000;
	a += b_type2 * 0.7743227044341611800000000;
	a += b_valvular * 0.8823685364057471900000000;
	a += fh_cvd * 0.2851807472688047700000000;

	/* Sum from interaction terms */

	a += age_1 * (smoke_cat==1) * -0.0021738924907283397000000;
	a += age_1 * (smoke_cat==2) * 0.0092958354691607976000000;
	a += age_1 * (smoke_cat==3) * -0.0238445203390637290000000;
	a += age_1 * (smoke_cat==4) * -0.0442081168504774720000000;
	a += age_1 * b_AF * -0.0378746660763275570000000;
	a += age_1 * b_CCF * -0.0703338932750366820000000;
	a += age_1 * b_chd * -0.1242795995222882000000000;
	a += age_1 * b_treatedhyp * -0.0547533824497907770000000;
	a += age_1 * b_type1 * -0.0104325848808183630000000;
	a += age_1 * b_type2 * -0.0543527244063423470000000;
	a += age_1 * b_valvular * -0.0681294786249953820000000;
	a += age_1 * bmi_1 * 0.0366468069607603160000000;
	a += age_1 * bmi_2 * 0.8374396689614352900000000;
	a += age_1 * fh_cvd * -0.0209588947842873420000000;
	a += age_1 * sbp * -0.0000512566841259084420000;
	a += age_1 * town * -0.0016537747988553985000000;
	a += age_2 * (smoke_cat==1) * 0.0000417982804007417310000;
	a += age_2 * (smoke_cat==2) * -0.0015127223843011640000000;
	a += age_2 * (smoke_cat==3) * 0.0018092337569956974000000;
	a += age_2 * (smoke_cat==4) * 0.0037591358040036760000000;
	a += age_2 * b_AF * 0.0026309641213272967000000;
	a += age_2 * b_CCF * 0.0052237718320413701000000;
	a += age_2 * b_chd * 0.0105765921592317290000000;
	a += age_2 * b_treatedhyp * 0.0045886801340551909000000;
	a += age_2 * b_type1 * -0.0031870689210806201000000;
	a += age_2 * b_type2 * 0.0044700226930346355000000;
	a += age_2 * b_valvular * 0.0052433370244195712000000;
	a += age_2 * bmi_1 * -0.0082953327794458437000000;
	a += age_2 * bmi_2 * -0.0642802685411782150000000;
	a += age_2 * fh_cvd * 0.0014106757779590851000000;
	a += age_2 * sbp * -0.0000179366158909618290000;
	a += age_2 * town * 0.0000037518903323942880000;

	/* Calculate the score itself */
	double score = 100.0 * (1 - pow(survivor[surv], exp(a)) );
	return score;
}

static int stroke_female_validation(
int age,int b_AF,int b_CCF,int b_chd,int b_ra,int b_renal,int b_treatedhyp,int b_type1,int b_type2,int b_valvular,double bmi,int ethrisk,int fh_cvd,double rati,double sbp,int smoke_cat,int surv,double town,char *errorBuf,int errorBufSize
)
{
	int ok=1;
	*errorBuf=0;
	if (!i_in_range(age,25,84)) {
		ok=0;
		strlcat(errorBuf,"error: age must be in range (25,84)\n",errorBufSize);
	}
	if (!is_boolean(b_AF)) {
		ok=0;
		strlcat(errorBuf,"error: b_AF must be in range (0,1)\n",errorBufSize);
	}
	if (!is_boolean(b_CCF)) {
		ok=0;
		strlcat(errorBuf,"error: b_CCF must be in range (0,1)\n",errorBufSize);
	}
	if (!is_boolean(b_chd)) {
		ok=0;
		strlcat(errorBuf,"error: b_chd must be in range (0,1)\n",errorBufSize);
	}
	if (!is_boolean(b_ra)) {
		ok=0;
		strlcat(errorBuf,"error: b_ra must be in range (0,1)\n",errorBufSize);
	}
	if (!is_boolean(b_renal)) {
		ok=0;
		strlcat(errorBuf,"error: b_renal must be in range (0,1)\n",errorBufSize);
	}
	if (!is_boolean(b_treatedhyp)) {
		ok=0;
		strlcat(errorBuf,"error: b_treatedhyp must be in range (0,1)\n",errorBufSize);
	}
	if (!is_boolean(b_type1)) {
		ok=0;
		strlcat(errorBuf,"error: b_type1 must be in range (0,1)\n",errorBufSize);
	}
	if (!is_boolean(b_type2)) {
		ok=0;
		strlcat(errorBuf,"error: b_type2 must be in range (0,1)\n",errorBufSize);
	}
	if (!is_boolean(b_valvular)) {
		ok=0;
		strlcat(errorBuf,"error: b_valvular must be in range (0,1)\n",errorBufSize);
	}
	if (!d_in_range(bmi,20,40)) {
		ok=0;
		strlcat(errorBuf,"error: bmi must be in range (20,40)\n",errorBufSize);
	}
	if (!i_in_range(ethrisk,1,9)) {
		ok=0;
		strlcat(errorBuf,"error: ethrisk must be in range (1,9)\n",errorBufSize);
	}
	if (!is_boolean(fh_cvd)) {
		ok=0;
		strlcat(errorBuf,"error: fh_cvd must be in range (0,1)\n",errorBufSize);
	}
	if (!d_in_range(rati,1,12)) {
		ok=0;
		strlcat(errorBuf,"error: rati must be in range (1,12)\n",errorBufSize);
	}
	if (!d_in_range(sbp,70,210)) {
		ok=0;
		strlcat(errorBuf,"error: sbp must be in range (70,210)\n",errorBufSize);
	}
	if (!i_in_range(smoke_cat,0,4)) {
		ok=0;
		strlcat(errorBuf,"error: smoke_cat must be in range (0,4)\n",errorBufSize);
	}
	if (!i_in_range(surv,1,15)) {
		ok=0;
		strlcat(errorBuf,"error: surv must be in range (1,15)\n",errorBufSize);
	}
	if (!d_in_range(town,-7,11)) {
		ok=0;
		strlcat(errorBuf,"error: town must be in range (-7,11)\n",errorBufSize);
	}
	return ok;
}

double stroke_female(
int age,int b_AF,int b_CCF,int b_chd,int b_ra,int b_renal,int b_treatedhyp,int b_type1,int b_type2,int b_valvular,double bmi,int ethrisk,int fh_cvd,double rati,double sbp,int smoke_cat,int surv,double town,int *error,char *errorBuf,int errorBufSize
)
{
	*error = 0;	int ok = stroke_female_validation(age,b_AF,b_CCF,b_chd,b_ra,b_renal,b_treatedhyp,b_type1,b_type2,b_valvular,bmi,ethrisk,fh_cvd,rati,sbp,smoke_cat,surv,town,errorBuf,errorBufSize);
	if(!ok) { 
		*error = 1;
		return 0.0;
	}
	return stroke_female_raw(age,b_AF,b_CCF,b_chd,b_ra,b_renal,b_treatedhyp,b_type1,b_type2,b_valvular,bmi,ethrisk,fh_cvd,rati,sbp,smoke_cat,surv,town);
}
